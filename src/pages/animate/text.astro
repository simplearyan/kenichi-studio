---
import Layout from "../../layouts/Layout.astro";
import { StudioEditor } from "../../features/studio/StudioEditor";
---

<Layout title="Kenichi Text Studio" showFooter={false}>
    <!-- Global styles moved to Layout or kept here if specific -->
    <style>
        :global(body) {
            background-color: #0f172a !important; /* slate-900 */
            color: white !important;
            overflow: hidden;
        }
        :global(body.light-mode) {
            background-color: #f8fafc !important; /* slate-50 */
            color: #1e293b !important; /* slate-800 */
        }
    </style>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Bangers&family=Inter:wght@100..900&family=Lobster&family=Merriweather:wght@300;400;700;900&family=Montserrat:wght@100..900&family=Oswald:wght@200..700&family=Pacifico&family=Playfair+Display:wght@400..900&family=Poppins:wght@100..900&family=Roboto+Mono:wght@100..700&display=swap"
        rel="stylesheet"
    />

    <div class="h-screen w-screen overflow-hidden">
        <StudioEditor client:only="react" allowedTabs={["text"]} />
    </div>
</Layout>

<script>
    import { StudioEngine } from "../../utils/studio/StudioEngine";
    import { CanvasText } from "../../utils/studio/renderers/CanvasText";

    let engine: StudioEngine;
    const canvas = document.getElementById(
        "studio-canvas",
    ) as HTMLCanvasElement;

    if (canvas) {
        engine = new StudioEngine(canvas);
        (window as any).studioEngine = engine;
        window.dispatchEvent(new Event("studio:ready"));

        // Initialize with Text
        const text = new CanvasText("text-1", {
            text: "Kenichi Text",
            x: 600,
            y: 400,
            fontSize: 100,
            color: "#60a5fa",
            animationType: "typewriter",
        });
        engine.addObject(text);
    }

    // --- Glue Logic (Simplified for Text Studio) ---
    // Only listening for text add
    window.addEventListener("studio:add-object", ((e: CustomEvent) => {
        if (!engine) return;
        const { type } = e.detail;
        if (type === "text") {
            const id = `text-${Date.now()}`;
            engine.addObject(new CanvasText(id, { x: 960 - 200, y: 540 }));
        }
    }) as EventListener);

    // --- Timeline & Playback (Copied generic logic) ---
    const playPauseBtn = document.getElementById("play-pause-btn");
    const stopBtn = document.getElementById("stop-btn");
    const iconPlay = document.getElementById("icon-play");
    const iconPause = document.getElementById("icon-pause");
    const timeCurrent = document.getElementById("time-current");
    const timeTotal = document.getElementById("time-total");
    const loopBtn = document.getElementById("loop-btn");
    const timelineContainer = document.getElementById("timeline-container");
    const timelineProgress = document.getElementById("timeline-progress");
    const timelineHandle = document.getElementById("timeline-handle");
    let isScrubbing = false;

    function updatePlayStateUI(isPlaying: boolean) {
        if (isPlaying) {
            iconPlay?.classList.add("hidden");
            iconPause?.classList.remove("hidden");
        } else {
            iconPlay?.classList.remove("hidden");
            iconPause?.classList.add("hidden");
        }
    }
    function updateTimelineUI(timeMs: number) {
        if (!engine) return;
        const total = engine.totalDuration;
        const pct = Math.max(0, Math.min(1, timeMs / total)) * 100;
        if (timelineProgress) timelineProgress.style.width = `${pct}%`;
        if (timelineHandle) timelineHandle.style.left = `${pct}%`;
        if (timeCurrent) timeCurrent.textContent = (timeMs / 1000).toFixed(2);
        if (timeTotal) timeTotal.textContent = (total / 1000).toFixed(2);
    }

    // Event Listeners
    window.addEventListener(
        "studio:timeupdate",
        ((e: CustomEvent) =>
            !isScrubbing && updateTimelineUI(e.detail.time)) as EventListener,
    );
    window.addEventListener("studio:playstate", ((e: CustomEvent) =>
        updatePlayStateUI(e.detail.isPlaying)) as EventListener);

    playPauseBtn?.addEventListener("click", () => {
        if (!engine) return;
        iconPause?.classList.contains("hidden")
            ? engine.play()
            : engine.pause();
    });
    stopBtn?.addEventListener("click", () => engine?.stop());
    loopBtn?.addEventListener("click", () => {
        if (engine) {
            engine.isLooping = !engine.isLooping;
            loopBtn.classList.toggle("text-blue-600");
            loopBtn.classList.toggle("text-gray-400");
            loopBtn.classList.toggle("bg-blue-50");
        }
    });

    if (timelineContainer) {
        const updateScrub = (e: MouseEvent) => {
            if (!engine) return;
            const rect = timelineContainer.getBoundingClientRect();
            const pct =
                Math.max(0, Math.min(e.clientX - rect.left, rect.width)) /
                rect.width;
            const targetTime = pct * engine.totalDuration;
            engine.seek(targetTime);
            updateTimelineUI(targetTime);
        };
        timelineContainer.addEventListener("mousedown", (e) => {
            isScrubbing = true;
            engine?.pause();
            updateScrub(e);
        });
        window.addEventListener("mousemove", (e) => {
            if (isScrubbing) {
                e.preventDefault();
                updateScrub(e);
            }
        });
        window.addEventListener("mouseup", () => {
            isScrubbing = false;
        });
    }
</script>
